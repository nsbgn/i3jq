// This tool has been adapted from:
// <https://github.com/itchyny/gojq/blob/0607aa5af33a4f980e3e769a1820db80e3cc7b23/_tools/gen_builtin.go>

package main

import (
	"flag"
	"fmt"
	"go/printer"
	"go/token"
	"os"
	"regexp"
	"strings"

	"github.com/itchyny/astgen-go"
	"github.com/itchyny/gojq"
)

const fileFormat = `// Code generated by _tools/gen_builtin.go; DO NOT EDIT.

package main
import (
	. "github.com/itchyny/gojq"
	"github.com/itchyny/gojq"
)
%s
`

func main() {
	var input, output string
	flag.StringVar(&input, "i", "", "input file")
	flag.StringVar(&output, "o", "", "output file")
	flag.Parse()
	if err := run(input, output); err != nil {
		fmt.Fprint(os.Stderr, err)
		os.Exit(1)
	}
}

func run(input, output string) error {
	cnt, err := os.ReadFile(input)
	if err != nil {
		return err
	}
	
	q, err := gojq.Parse(string(cnt))
	if err != nil {
		return err
	}
	for _, fd := range q.FuncDefs {
		fd.Minify()
	}
	str, err := formatQuery(q)

	out := os.Stdout
	if output != "" {
		f, err := os.Create(output)
		if err != nil {
			return err
		}
		defer f.Close()
		out = f
	}
	_, err = fmt.Fprintf(out, fileFormat, *str)
	return err
}

func getName(q *gojq.Query) *string {
	if q.Meta != nil {
		for _, kv := range q.Meta.KeyVals {
			if kv.Key == "name" {
				return &kv.Val.Str
			}
		}
	}
	return nil
}

func formatQuery(q *gojq.Query) (*string, error) {
	// Get abstract syntax tree of query
	ast, err := astgen.Build(q)
	if err != nil {
		return nil, err
	}

	// Turn AST into a string
	var sb strings.Builder
	var name = getName(q)
	sb.WriteString("\nvar ")
	sb.WriteString(*name)
	sb.WriteString("Query = ")
	err = printer.Fprint(&sb, token.NewFileSet(), ast)
	if err != nil {
		return nil, err
	}
	str := sb.String()

	// Convert integers to proper enums
	for op := gojq.OpPipe; op <= gojq.OpUpdateAlt; op++ {
		re := regexp.MustCompile(fmt.Sprintf(`\b((?:Update)?Op): %d\b`, op))
		str = re.ReplaceAllString(str, fmt.Sprintf("$1: %#v", op))
	}
	for t := gojq.TermTypeIdentity; t <= gojq.TermTypeQuery; t++ {
		re := regexp.MustCompile(fmt.Sprintf(`(Term{Type): %d\b`, t))
		str = re.ReplaceAllString(str, fmt.Sprintf("$1: %#v", t))
	}

	return &str, nil
}
