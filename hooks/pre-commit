#!/bin/sh
# Putting generated code under source control feels *wrong*. It requires you to
# manually keep pairs of files in sync --- only one of which is a source ---
# and it clutters the diffs with gibberish.
#
# Nevertheless, to enable a painless installation using `go install ...`, it is
# necessary. It also seems encouraged by the Go devs:
#
# > "... once the file is generated (and tested!) it must be checked into the
# source code repository ..."
# ~ Rob Pike, 2014-12-22, <https://go.dev/blog/generate>, accessed 2024-07-03.
#
# To mitigate the mental burden of keeping files in sync, this pre-commit hook
# checks if any source builtin was changed and the differences staged, and if
# so, runs `go generate` to check if the staged `builtin.go` corresponds to the
# one generated from the current working tree. If not, the commit will fail: to
# keep the process transparent (and make sure that I didn't make a mistake),
# the generated file will then need to be added manually.

# TODO: Since go generate is not ran against the *staged* changes but just
# against the current working tree, this doesn't do exactly what I want yet.

builtin_dir="builtin"
builtin_gen="builtin.generator.go"
builtin_go="builtin.go"

builtins_changed() {
    if [ ! -d "${builtin_dir}" ]; then
        echo "Could not find ${builtin_dir}/. Aborting commit." 1>&2
        exit 1
    fi
    git diff --cached --name-only --diff-filter=ACM | \
        grep "^\(\.\./\)*${builtin_dir}/.*\.jq$\|^${builtin_gen}$"
    return $?
}

staged_changes_match() {
    if [ ! -e "${builtin_gen}" ]; then
        echo "Could not find ${builtin_gen}. Aborting commit." 1>&2
        exit 1
    fi
    tmpfile="$(mktemp)"
    trap "rm -f ${tmpfile}" EXIT
    if ! go run -modfile=go.dev.mod ${builtin_gen} > ${tmpfile}; then
        echo "Could not run ${builtin_gen}. Aborting commit." 1>&2
        exit 1
    fi
    # TODO run git diff against staged changes
    git diff --exit-code "${builtin_go}" "${tmpfile}" > /dev/null
    return $?
}

# Copy the staged version of a file/directory to somewhere
copy_staged() {
    local src="${1}"
    local goal="${2}"
    if [ -d "${src}" ]; then
        mkdir -p "${goal}"
        for path in "${src}"/*; do
            copy_staged "${path}" "${goal}/${path##${src}/}"
        done
    elif [ -f "${src}" ]; then
        if git cat-file -e :"${src}" 2> /dev/null; then
            git cat-file -p :"${src}" > "${goal}"
        fi
    else
        echo "${src} does not exist. Aborting commit." 1>&2
        exit 1
    fi
}

cd "$(git rev-parse --show-toplevel)"
if builtins_changed; then
    echo "Builtins have staged changes. Checking that ${builtin_go} is in sync..." 1>&2
    if ! staged_changes_match; then
        echo 'The staged changes are not in sync. Aborting commit.' 1>&2
        exit 1
    fi
fi
